NAME: Jonathan Chon
EMAIL: jonchon@gmail.com
ID: 104780881

2.1.1 - Causing Conflicts:
It takes many iterations before errors are seen because more iterations increases
the chances of race conditions in the critical section.
With significantly smaller number of iterations, there are less errors because the
chances of race conditions in the critical section is lower.

2.1.2 - Cost of Yielding
The --yield runs are much slower since the yield flag causes the threads to be
interrupted. By yielding the CPU, there are context switches to allow other
threads to run, which causes overhead.
The additional time is going to the context switches.
It is not possible to get valid per-operation times using --yield since the overhead
from context switches are included in the running time.

2.1.3 - Measurement Errors
The reason that the cost per operation decreases with increasing number of iterations
is because when the number of iterations is small, the time it takes to create the threads
is a big factor. However, since the time it takes to create the threads is constant, as 
the number of iterations increases, the overhead from creating the threads is not as great
of a factor. Thus, as the number of iterations goes towards infinity, the cost per operation
approaches the actual cost per operation without considering the time it takes to create threads.

2.1.4 - Costs of Serialization
Since there are only a few threads, the threads do not have to wait for long before they get
possession of the lock. In addition, in a multiprocessor system, for a low amount of threads,
each thread will get their own CPU to run on. 
As the number of threads rise, the protected operations slow down since there is added overhead
due to locking. Other threads that do not have the lock will be blocked and will have to wait for
their turn to obtain the lock and run the critical sections. This results in a waste of CPU.

2.2.1 - Scalability of Mutex
Looking at both plots for per operation cost vs number of threads, as the number of threads
increases, lab2_add has an increasing curve that eventually flattens out, which lab2_list
has a curve that increases linearly throughout. The reason that these
curves rise initially is because the overhead added as a result of locking and unlocking the mutex.
However, lab2_add eventually flattens out because the thread does not have the lock, it goes to
sleep, which prevents the threads from wasting CPU by simply spinning. lab2_list has a constant
linear slope since list opperations are more expensive than add operations, making the overhead
have a larger role in the cost per operation than the waste of CPU by locking.

2.2.2 - Scalability of Spin Locks
Aside from one thread in the lab2_add, spin locks cause cost per operation to grow linearly with
threads. This is because spin locks are inefficient, and as more threads enter into the scene,
more threads waste the CPU by simply spinning. In a spin lock, only one thread has the lock, causing
the other threads to constantly check to see if they have obtained the lock when there is no
possible way for that to change since the thread with the lock is not currently running. The
graphs for both lab2_add and lab2_list for spin lock increases at a much higher rate than mutexes
since spin lock does not make the threads sleep when they do not have the lock, something that
mutex locks do.

Files Included in the tar file:
README:
Gives answers to each of the questions on the specs and includes descriptions of each file in the
tarball as well as the websites used for extra information

Makefile:
Has commands to build all programs, run the tests that generate results and stores them in the
.csv files, graph the infromation from the .csv files into a plot, create the tarball, and remove
all of the files created by itself

SortedList.h:
Lists the methods implemented in SortedList.c and contains the definitions for SortedList_t and
SortedListElement_t

SortedList.c:
Implements the methods listed in SortedList.h. Has different methods to add a node to a circularly
linked list, delete a node from a circularly linked list, count the amount of nodes, and lookup
the location of a particular node.

lab2_add.c:
Source code for a program that increments and decrements a counter using different methods of
protection against race conditions in critical sections

lab2_list.c:
Source code for a program that uses threads to use the methods defined in SortedList.c and apply
them. Contains protection against race conditions in critical sections

*.png:
Contains the generated plots from the information in the respective .csv files

*.csv:
Contains the data generated by running the tests listed in the specs, which are contained in the
.sh files.

*.sh:
contains the test conditions for lab2_add and lab2_list as specified in the specs.


Websites Used:
https://www.softwariness.com/articles/monotonic-clocks-windows-and-posix/
https://stackoverflow.com/questions/17779570/printing-long-int-value-in-c